在C++中，编译器可以保证你永远不能对const变量进行修改，所以C++的const我们可以称其为“真”const。 
然而在c语言中，并不能保证被const声明的变量不会被修改，所以其主要就是个语义作用，就是告诉你别动它了。

在C++中创建指针时，计算机将分配用来存储地址的指针，但不会分配用来存储指针所指向的数据的内存，
一定要在对指针应用解引用运算符*之前，将指针初始化为一个确定的、适当的地址。

自动变量通常存储在栈中，这意味着执行代码块时，其中的变量将依次加入到栈中，而在离开代码块时，
将按相反的顺序释放这些变量，这被称为后进先出（LIFO），因此在程序执行过程中，栈将不断增加和缩小。

new和delete运算符管理了一个内存池，这在C++中被称为自由存储空间（free store）或堆（heap），
该内存池同用于静态变量和自动变量的内存是分开的，能够在一个函数中分配内存，而在另一个函数中释放它，
因此数据的生命周期完全不受程序或函数的生存时间控制。

在栈中，自动添加和删除机制使得占用的内存总是连续的，但new和delete相互影响可能导致占用的
自由存储区不连续，这使得跟踪新分配的内存的位置更困难。

数组的静态联编，即数组的长度在编译时设置：
int tacos[10]；
使用new[]运算符创建数组时，将采用动态联编（动态数组），即将在运行时为数组分配空间，
其长度也在运行时设置，使用完这种数组后，应使用delete[]释放其占用的内存：
int size;
cin>>size;
int * pz=new int [size];
...
delete [] pz;

返回引用最重要的一点是应避免返回函数终止时不再存在的内存单元，同样，也应避免返回指向临时变量的指针。
为避免这种问题，最简单的方法是，返回一个作为参数传递给函数的引用。
另一种方法是用new来分配新的存储空间，如：
free_throws & clone(free_throws & ft)
{
free_throws * pt=new free_throws;
*pt=ft;
return *pt;
}
第一条语句创建一个匿名的free_throws结构，并让指针pt指向该结构，因此*pt就是该结构。该函数实际将
返回这个结构的引用，这样，便可以这样使用该函数：free_throws & jolly=clone(three);
这使得jolly成为新结构的引用，这种存在一个问题：在不再需要new分配内存时，应使用delete释放它们。
可以使用auto_ptr模板或者C++11新增的unique_ptr自动完成释放过程。

accumulate(dup,five)=four;
该语句的效果是首先将five的数据添加到dup中，再使用four的内容覆盖dup的内容。这条语句为什么能通过编译？
在赋值语句中，左边必须是可修改的左值，也就是说，在赋值表达式中，左边的子表达式必须标识一个可修改的
内存块，在这里，函数返回指向dup的引用，它确实标识一个这样的内存块，因此这条语句是合法的。
假设要使用引用返回值，又不允许执行像给accumulate（）赋值这样的操作，只需将返回类型声明为const引用。

常规（非引用）返回类型是右值——不能通过地址访问的值，这种表达式可出现在赋值语句的右边，但不能出现
在左边。其它右值包括字面值（10.0）和表达式（x+y）。常规函数返回值是右值是因为这种返回值位于临时内存单元中，运行到
下一条语句时可能不再存在。

对于带参数列表的函数，必须从右向左添加默认值，实参按从左到右的顺序依次被赋给相应的形参，而不能跳过任何参数。
只有函数原型指定默认值，函数定义与没有默认参数时完全相同。

函数重载的关键是函数的参数列表，也称为函数特征标（function signature），如果两个函数的参数数目和
类型相同，同时参数的排列顺序也相同，则它们的特征标相同，C++允许定义名称相同的函数，前提是它们的
特征标不同，如果参数数目/或参数类型不同，则特征标也不同。
编译器把类型引用和类型本身视为同一个特征标。
两个函数的参数中有const和非const变量时，编译器将根据实参是否为const决定使用哪个原型。
返回类型可以不同，但特征标也必须不同。

函数模板允许以任意类型的方式来定义函数，模板并不创建任何函数，而只是告诉编译器如何定义函数：
template <typename AnyType>
void Swap(AnyType &a,AnyType &b){}
在C++98标准之前使用关键字class来创建模板，即：
template <class AnyType>
这两种关键字是等价的
模板可以重载，函数特征标必须不同，并非所有的模板都必须是模板参数类型

显式具体化（explicit specialization）提供一个具体化函数定义，当编译器找到与函数调用匹配的
具体化定义时，将使用该定义，而不再寻找模板。
用于交换job结构的非模板函数，模板函数和具体化的原型：
void Swap(job &,job &);

template <typename T>
void Swap(T &,T &);

template <> void Swap<job>(job &,job &);//或template <> void Swap(job &,job&);
如果有多个原型，则编译器在选择原型时，非模板版本优先于显式具体化和模板版本，
而显式具体化优先于使用模板生成的版本。

显式实例化（explicit instantiation）可以直接命令编译器创建特定的实例，其语法是
声明所需的种类——用<>符号指示类型，并在声明前加上关键字template：
template void Swap<int>(int &,int &);
与显式具体化的区别是，显式具体化在关键字template后包含<>,而显式实例化没有。

如果文件名包含在尖括号中，则编译器将在存储标准头文件的主机系统的文件系统中查找；
但如果文件包含在双引号中，则编译器将首先查找当前的工作目录或源代码目录（或其它目录，这取决于编译器），
如果没有在那里找到头文件，则将在标准位置查找。因此包含自己的头文件时应使用引号而不是尖括号。

只需将源代码文件加入到项目中，而不用加入头文件，这是因为#include指令管理头文件，
另外，不要使用#include来包含源代码文件，这样做会导致多重声明。

头文件管理：
#ifndef COORDIN_H_
#define COORDIN_H_
//place include file contents here
#endif
这种方法不能防止编译器将文件包含两次，而只是让它忽略除第一次包含之外的所有内容。

不同编译器将为同一个函数生成不同的修饰名称，名称的不同
将使链接器无法将一个编译器生成的函数调用与另一个编译器生成的函数定义匹配。
在链接编译模块时，确保所有对象文件都是由同一个编译器生成的。

程序使用两个指针来跟踪栈，一个指针指向栈底（栈开始的地方），另一个
指针指向栈顶（下一个可用的内存单元），当函数被调用时，其自动变量将被
加入到栈中，栈顶指针指向变量后面的下一个可用的内存单元。函数结束时，
栈顶指针被重置为函数被调用前的值，从而释放新变量使用的内存。
（例图见c++primeplus253页图9.3）

由于静态变量的数目在程序运行期间是不变的，编译器将分配固定数目的内存块来存储
所有的静态变量，这些变量在整个程序执行期间一直存在。
另外，如果没有显式初始化静态变量，编译器将把它设置为0，默认情况下，
静态数组和结构将每个元素或成员的所有位都设置为0。

静态持续变量提供3种链接性：
外部链接性（可在其它文件中访问）
内部链接性（只能在当前文件中访问）
无链接性（只能在当前函数或代码块中访问）
实例：
---
int global=1000;//external linkage
static int one_file=50;//internal linkage
int main(){---}
void funct1(int n)
{
static int count=0;//no linkage
---
}
上述示例中的静态变量global,one_file,count在整个程序执行期间都存在。

在代码块中使用static时，将导致局部变量的存储持续性为静态的，这意味着
虽然该变量只在该代码块中可用，但它在该代码块不处于活跃状态时仍然存在，
因此在两次函数调用之间，静态局部变量的值将保持不变，另外，如果初始化了
静态局部变量，则程序只在启动时进行一次初始化，以后再调用函数时，将
不会像自动变量一样再次被初始化。

C++有单定义规则（One Definition Rule,ODR）,该规则指出，变量只能有一次定义。
为满足这种需求，C++提供两种变量声明：一种是定义声明，它给变量分配存储空间；
另一种是引用声明，它不给变量分配存储空间，因为它引用已有的变量，
引用声明使用关键字extern，且不进行初始化；否则，声明为定义，导致分配存储空间。

在多文件程序中，可以在一个文件（且只能在一个文件）中定义一个外部变量（单定义规则），
使用该变量的其它所有文件中，都必须使用关键字extern声明它：
//file01.cpp
extern int cats=20;
int dogs=22;
int fleas;
...
//file02.cpp
//use cats and dogs from file01.cpp
extern int cats;
extern int dogs;
...
//file98.cpp
//use cats,dogs,and fleas from file01.cpp
extern int cats;
extern int dogs;
extern int fleas;
...
在文件file01.cpp中，关键字extern即使省略，效果也相同，只要进行初始化就是定义声明，
extern声明引用在其它地方中（外部）定义的变量。

在函数中定义全局变量与局部变量后，局部变量将隐藏全局变量，
C++提供作用域解析符（：：），放在变量名前面时，该运算符表示使用变量的全局版本。
从清晰和避免错误的角度说，在函数中使用：：warming是更好的选择，也更安全。

cv限定符const，volatile，const表明内存被初始化后程序便不能再对它进行修改；
volatile表明，即使程序代码没有对内存单元进行修改，其值也可能发生变化，例如
将一个指针指向某个硬件位置，其中包含来自串行端口的时间或信息，该关键字的
作用是为了改善编译器的优化能力，例如程序两次使用某个变量的值，编译器可能
不会让程序查找这个值两次，而是将这个值缓存到寄存器中，这种优化假设变量的值不会变化。
将变量声明为volatile相当于告诉编译器不要进行这种优化。

mutable可以用来指出，即使结构或类变量为const，其某个成员也可以被修改。

在C++中，默认情况下全局变量的链接性为外部的，但const全局变量的链接性为内部的，
就像使用static说明符一样。如果出于某种原因，希望某个常量的链接性为外部的，
可以使用extern关键字来覆盖默认的内部链接性：
extern const int states=50;
在头文件使用const，由于其内部链接性，每个文件都有自己的一组常量，
而不是索要文件共享一组常量，每个定义都是其所属文件私有的，不同于#define等全局变量
如果被多个文件包含会面临冲突的问题。

在C和C++中，所有函数的存储持续性都自动为静态的，即在整个程序执行期间一直存在。
在默认的情况下，函数的链接性为外部的，即可以在文件之间共享。

可以在函数原型中使用关键字extern来指出函数是在另一个文件中定义的，这是可有可无的。

还可以使用关键字static将函数的链接性设为内部的，必须同时在函数原型和定义中使用该关键字，
这意味着该函数只在这个文件中可见，还意味着可以在其它文件中定义同名的函数。
和变量一样，在定义静态函数的文件中，静态函数将覆盖外部定义。

头文件一般而言，是函数声明，以.h结尾，是文本的形式，ASCII码的形式。
库文件是已经编译好的二进制代码，可以是动态的.so，在程序运行时提供支持；
可以是静态的.a，最后生成的可执行程序可以脱离库文件独立运行。

对于非内联函数，适用于单定义规则，只能有一个文件（可能是库文件）包含该函数的定义，
但使用该函数的每个文件都应包含其函数原型。
对于内联函数，不受单定义规则的约束，允许程序员将定义放在头文件里，每个包含头文件的
文件都有内联函数的定义，但是C++要求同一个函数的所有内联定义都必须相同。

C++调用函数查找定义的顺序：如果函数原型使用了关键字static，则编译器将只在该文件中查找函数定义，
否则，编译器将在所有程序文件中查找；如果找到两个定义，编译器将发出错误消息，如果没有找到，编译器
将在库中搜索。
这意味着如果定义了一个与库函数同名的函数，编译器将使用程序员定义的版本而非库函数。（不应使用）

链接程序要求每个不同的函数都有不同的符号名。在C语言中，一个名称只对应一个函数，编译器将
spiff这样的函数名翻译为_spiff，这种方法被称为C语言链接性（C language linking)；
在C++中，同一个名称可能对应多个函数，必须翻译为不同的符号名称，编译器执行名称修饰为重载函数
生成不同的符号名称，如将spiff(int)转换为_spiff_i，将spiff(double,double)转换为_spiff_d_d，
这种方法被称为C++语言链接性（C++ language linking）。

C++链接程序寻找调用函数使用的约定与C语言不同，如果在C++程序中使用C库中预编译的函数，
由于表示的符号名称不同，可以用函数原型来指出要使用的约定：
extern "C" void spiff(int);//use C protocol for name look-up
extern void spiff(int);//use C++ protocol for name look-up
extern "C++" void spiff(int);//use C++ protocol for name look-up
第一个原型使用C语言链接性，后面两个使用C++语言链接性。
C和C++链接性是C++标准指定的说明符，但实现可提供其它语言链接性说明符。

虽然存储方案不适用于动态内存，但适用于用来跟踪动态内存的自动和静态指针变量。如：
float * p_fees=new float [20];
由new分配的内存将一直保留直到使用delete运算符释放，但当包含该声明的语句块执行完毕后，
p_fees指针将消失。如果希望另一个函数能够使用内存中的内容，则必须传递其地址；如果将
指针的链接性声明为外部的，则文件中位于该声明后的所有函数都可以使用它；此外，在另一个文件
中使用声明extern float * p_fees；便可在其中使用该指针。

使用new初始化动态分配的变量：
int *pi=new int (6);
double *pd=new double (9.9);
这种括号语法也适用于有合适构造函数的类。
struct where {double x;double y;double z};
初始化常规结构或数组需要使用的大括号列表初始化，要求支持C++11：
where * one=new where {2.5,5.3,7.2};//C++11
int * ar=new int [4] {2,4,6,7};//C++11
在C++11中，还可以将列表初始化用于单值变量：
int *pi=new int {6};
double * pd=new double {9.9};

通常new负责在堆（heap）里找到一个足以满足要求的内存块，new运算符还有另一个变体，
被称为定位（placement）new运算符，它可以让程序员指定要使用的位置，程序员可以使用
这个特性来设置内存管理规程、处理需要通过特定地址访问的硬件或在特定位置创建对象。

包含头文件new来使用定位new特性。除需要指定参数buffer外，定位new用法与常规new相同.
#include <new>
const int BUF=512;
const int N=5;
char buffer[BUF];//一块指定的静态内存
int main()
{
double * pd1=new double[N]//use heap
double * pd2=new (buffer) double[N];//use buffer array
——省略数组赋值循环语句——
cout<<"heap: "<<pd1<<" static: "<<(void *)buffer<<endl;
delete [] pd1;
pd1=new double[N];
pd2=new (buffer+N*sizeof(double)) double[N];
delete [] pd1;
}
常规new将数组pd1放在动态管理的堆中；
而定位运算符确实将数组pd2放在了数组buffer中，它们的地址相同，然而类型不同。
pd2是double类型指针，而buffer是char指针（这也是使用（void *）进行强制类型转换的原因）。
定位new运算符不会跟踪哪些内存单元已被使用，也不查找位使用的内存块，因此既可以再次分配
与以前相同的内存块，也可以为一个从数组buffer开头算起的偏移量分配内存。
由于buffer指定的内存是静态内存，因此不用delete来释放内存；
delete只能用于这样的指针：指向常规new运算符分配的堆内存。
定位new函数不可替换，但可以重载，它至少需要接收两个参数，第一个总是std::size_t，
这样的重载函数都被称为定义new，即使额外的参数没有指定位置。

通过定义一种新的声明区域来创建命名的名称空间，名称空间可以是全局的，
也可以位于另一个名称空间中，但不能位于代码块中，因此默认情况下，
在名称空间中声明的名称链接性为外部的（引用常量除外）。

namespace Jack{
double pail;//variable declaration
void fectch;//function declaration
struct Well{...};//structure declaration
}
名称空间是开放的（open)，可以把名称加入到已有的名称空间中，例如：
namespace Jack{
char * goose(const char *);
}
原来的Jack名称空间为fetch函数提供了原型，可以在该文件后面或另一个文件中
再次使用Jack名称空间提供该函数的代码：
namespace Jack{
void fetch(){...}
}

除了用户定义的名称空间外，还有另一个名称空间，全局名称空间(global namespace)，
全局变量就位于全局名称空间中。

通过作用域解析符：：使用名称空间来限定该名称。未被装饰的名称如pail称为未限定的名称（unqualified name);
包含名称空间的名称如Jack：：pail称为限定的名称（qualified name)。

C++提供两种机制来简化对名称空间的使用。
using声明使特定的一个名称可用，如：using Jack::fetch；
当using声明将名称添加到局部声明区域内，要避免将另一个局部变量命名为fetch，
此外，fetch也像局部变量一样覆盖同名的全局变量。
在函数外面使用using声明时，将把名称添加到全局名称空间中；

using编译指令使名称空间中的所有名称都可用，不需要使用作用域解析符。
using编译指令由名称空间名和它前面的关键字using namespace组成。

使用using声明比shiyongusing编译指令更安全，因为它只导入指定的名称，
如果该名称与局部名称发生冲突，编译器会发出警告；using编译指令导入所有名称，
如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，编译器并不会发出警告。

可以将名称空间声明进行嵌套：
namespace elements{
namespace fire{
int flame;
...
}
float water;
}
这里的flame指的是elements::fire::flame,可以使用using编译指令使内部的名称可见：
using namespace elements::fire;
此外，也可以在名称空间中使用using编译指令和using声明：
namespace myth{
using Jack::fetch;
using namespace elements;
using std::cout;
using std::cin;
}
可以用myth::fetch，Jack::fetch或者fetch访问Jack：：fetch；
由于using编译指令是可传递的，使用语句using namespace myth；
将导入名称空间myth和elements。

可以给名称空间创造别名，来简化对嵌套名称空间的使用：
namespace MEF=myth::elements::fire;

可以通过省略名称空间的名称创建未命名的名称空间，由于不能显式的使用
using，即不能在未命名名称空间所属文件之外使用该名称空间中的名称，
它提供了链接性为内部的静态变量替代品：
namespace //unnamed namespace
{
int ice;
}

程序员使用名称空间的指导原则：
使用已命名的名称空间中声明的变量，而不是使用外部全局变量；
使用已命名的名称空间中声明的变量，而不是使用静态全局变量；
如果开发了一个函数库或类库，将其放在一个名称空间中；
（C++提倡将标准函数库放在名称空间std中，这种做法拓展到了来自C语言中的函数，
如math.h没有使用名称空间，但是头文件cmath应将各种数学库放在名称空间std中，
并非所有编译器都能实现这点）
不要在头文件中使用using编译指令，这样会掩盖要让哪些名称可用；
对于using声明，首选将其作用域设置为局部而非全局；

