#第十一章 使用类
##运算符重载
 运算符函数的格式：
**operatorop(argument-list)** 
如operator+()重载+运算符。op必须是有效的C++运算符，不能虚构一个新的符号。

* 例如假设有一个Salesperson类，并定义了一个operator+（）成员函数，以便能够将两个Salesperson对象相加，则如果district2，sid，sara都是Salesperson类对象，便可以编写等式：
**district2=sid+sara；**
编译器将使用相应的运算符函数替换上述运算符：
**district2=sid.operator+(sara);**
该函数将隐式使用sid，显式使用sara对象（因为它被作为参数传递）来计算总和，并返回这个值。==在运算符表示法中，运算符左侧的对象是调用对象，右边的对象是作为参数被传递的对象。==
##重载限制
1. 重载的运算符不必是成员函数，但必须至少有一个操作数是用户定义的类型，
这防止用户为标准类型重载运算符，如两个double类型相加。
2. 使用运算符时不能违反运算符原来的句法规则，如不能将求模运算符%重载为使用一个操作数。
3. 同样，不能修改运算符的优先级。
4. 不能创建新运算符。
5. 不能重载这些运算符：
* sizeof运算符
* .成员运算符
* .*成员指针运算符
* ::作用域解析运算符
* ?:条件运算符。
6. 这些运算符只能通过成员函数进行重载：
* =赋值运算符
* ()函数调用运算符
* []下标运算符
* ->通过指针访问类成员的运算符。

#####表中的运算符大部分可以通过成员函数或非成员函数进行重载：
|+|-|*|/|%|^|
|-|-|-|-|-|-|
|&|&#124;|~=|!|=|<
|+=|-=|*=|/=|%=|>
^=|&=|`|=`|<<|>>|>>=
<<=|==|!=|<=|>=|&&
`||`|++|--|,|->*|->
|()|[]|new|delete|new[]|delete[]|
除了以上所说的限制外，不应让运算符做与本意不相符的工作，最好定义一个单独的具有说明性的类方法。
##友元
友元有三种：
* 友元函数
* 友元类
* 友元成员函数

在为类重载二元运算符（带两个参数的运算符）时，常常需要友元。原因是对于操作数使用不同类型的重载运算符来说，左侧的操作数必须是调用对象，例如：```A=B*2.75;```
将被转换为成员函数调用：```A=B.operator*(2.75);```
但下面的语句就不能识别为成员函数：```A=2.75*B;```
因为2.75不是Time类型的对象，编译器不能使用成员函数替换它。
解决方法是非成员函数，非成员函数不是由对象调用的，它的所有值都是显式参数，这样编译器就能将表达式与下面的非成员函数的原型相匹配：```Time operator*(double m,const Time & t);```

这引发了一个新问题，非成员函数不能直接访问类的私有数据，但是有一类特殊的非成员函数可以访问类的私有成员，它们被称为友元函数。
###创建友元函数
创建友元函数第一步是将其原型放在类声明里，并在原型声明前加上关键字friend：
```friend Time operator*(double m,const Time & t);```
该原型说明：
* 虽然operator*（）函数是在类声明中声明的，但它不是成员函数，因此不能使用成员运算符来调用；
* 虽然operator*（）函数不是成员函数，但它的访问权限与成员函数相同。

第二步是编写函数定义，由于它不是成员函数，不需要使用作用域解析符::，且在定义中不能使用关键字friend：
```Time operator*(double m,const Time & t){}```
也可以将它编写为非友元函数：
```C++
Time oprerator*(double m,const Time & t)
{
    return t*m;
}
```
原来的版本显式的访问，必须是友元，这个版本让成员函数来处理私有值，因此不必是友元。但将这个版本作为友元可以让它成为类接口的组成部分，且以后如果需要直接访问私有数据时只修改函数定义即可，不需要修改类原型。==如果要为类重载运算符，并将非类的项作为第一个操作数，就可以用友元函数来反转操作数的顺序。== 这样的友元函数代码很短时，可以作为内联函数将定义直接写在原型里。
###常用的友元：重载<<运算符
一个有用的类特性是，可以对<<运算符重载，与cout一起显示对象的内容。

我们已经知道，cout是一个ostream对象，它能够识别所有C++基本类型，这是因为对于每种基本类型，ostream类声明中都包含了相应的重载的operator<<()定义，因此要使cout能够识别Time对象，可以通过Time类声明来让Time类知道如何使用cout。

这样做必须使用友元函数，因为如果使用一个Time类成员函数来重载<<，Time对象必须是第一个操作数，这意味着必须这样使用：
```time<<cout;```
通过使用友元函数，可以这样重载运算符：
```C++
void operator<<(ostream & os,const Time & t)
{
    os<<t.hours<<"hours, "<<t.minutes<<"minutes";
}
 这样可以使用下面的语句：
 cout<<time;
 ```
operator<<()函数不是ostream类的友元，因为该函数只访问了Time对象的私有成员，从始至终都将ostream对象作为一个整体使用，所以不必是ostream类的友元。

对于语句```cout<<x<<y;```，C++从左至右读取输出语句，意味着它等同于```(cout<<x)<<y;```，在iostream的定义中，<<运算符要求左边是一个ostream对象，而ostream类使operator<<()函数返回一个指向调用对象（cout）的引用，表达式(cout<<x)本身就是ostream对象cout，从而可以在<<运算符左侧。

可以修改operator<<()函数的定义，让它返回ostream对象的引用，这样就也可以用在cout的连续输出中：
```C++
ostream & operator<<(ostream & os,const Time & t)
{
    os<<t.hours<<"hours, "<<t.minutes<<"minutes";
    return os;
}
```
然后下面的语句便可以正常工作：
```cout<<"Time: "<<time<<"Tuesday\n";```
### 一个矢量类
仅把一些独特的设计抽取出来，具体代码见书326页。

#### 弧度与角度的转换
1 degree=180/$\pi$ radian
1角度=180/$\pi$弧度
==C/C++的数学计算函数使用弧度而不是角度，使用角度必须进行换算。==
可以使用atan(1.0)计算出$\pi$/4的值，即```PI=4*atan(1.0);```，那么1弧度就等于45.0/atan(1.0)角度，1角度等于atan(1.0)/45.0弧度，可以在三角函数运算里用这两个式子进行弧度与角度之间的转换：
```const double Rad_to_Deg=45.0/atan(1.0);```

在数学中magnitude表示量级，在矢量中它表示的是矢量的大小length of vector，计算矢量大小的函数可以写成```mag=sqrt(x*x+y*y);```

C语言中double atan2(double y,double x)函数返回以弧度表示的y/x的反正切，即原点至点(x,y)的方位角，即与x轴的夹角。

可以用不同但等价的方式表示量，类非常适用于在一个对象中表示实体的不同方面，首先在一个对象存储多种表示方式，然后编写一个给一种表示方式赋值，自动给其它表示方式赋值的类函数，通过在内部处理转换，类允许从本质上来看待一个量。

例如弧度和角度，可以使用状态成员(state member)来区分它们,这种成员描述的是对象所处的状态,在类声明中用枚举表示不同的状态：
  ```C++
class Vector{
    public:
    enum Mode{RECT,POL};
    private:
    Mode mode;
}
```

在这里，RECT表示直角坐标模式（默认值），POL表示极坐标模式。标识符POL和RECT的作用域为类，在类外使用必须加上类名和作用域解析符，如在友元函数中使用Vector::RECT 。作为函数参数时，由于int整型不能隐式转换为枚举类型，可以用Vector::Mode(1)显式转换。

如果方法通过计算得到一个新的类对象，则应考虑是否可以使用类构造函数完成这种工作，这样做不仅能够避免麻烦，还可以确保新对象按照正确的方式生成。

类构造函数样例：
```C++
Vector::Vector(double n1,double n2,Mode form=RECT)
{
    mode=form;
    if(form==RECT)
    {
        x=n1;
        y=n2;
        set_mag();
        set_ang();
    }
    else if(form==POL)
    {
        mag=n1;
        ang=n2/Rad_to_deg;
        set_x();
        set_y();
    }
    else
    {
        cout<<"Incorrect 3rd argument to Vector()---";
        cout<<"Vector set to 0\n";
        x=y=mag=ang=0.0;
        mode=RECT;
    }
}
```

将一系列位置信息存储到文件中很容易，首先包含头文件fstream，声明一个ofstream对象，将其同一个文件关联起来：
 ```C++
#include <fstream>
...
ofstream fout;
fout.open("thewalk.txt");
```
然后在计算结果的循环里加入类似于这样的代码：
```fout<<result<<endl;```
这将调用友元函数operator<<(fout,result)，由于类继承属性让ostream引用能够指向ostream对象和ofstream对象，使引用参数指向fout，从而将输出写入文件中，还可以用fout写入其它信息到文件中，如由cout显示的总结信息。==这种方法可以用来生成日志文件log.txt。==
## 类的自动转换和强制类型转换
接受一个参数的构造函数定义了从参数类型到类类型的转换：
```Stonewt(double lbs); //template for double-to-Stonewt conversion```  
也就是说，可以编写这样的代码：
```C++
Stonewt mycat;
mycat=19.6;
```
程序将使用构造函数Stonewt（double）来创建一个临时对象，并将19.6转化为初始化值，然后采取逐成员赋值的方式将临时对象的内容复制到mycat中，这一过程是隐式转换。且==只有接受一个参数的构造函数才能作为转换函数，但是如果给第二个参数提供默认值也可以转换。==

将构造函数用作自动类型转换函数这个特性可能会导致意外的类型转换，因此可以使用关键字explicit关闭它：
```explicit Stonewt(double ws);```
这将关闭隐式转换，但是仍然允许显式转换，即显式强制转换：
```mycat=(Stonewt)19.6;```
如果不在声明中使用explicit关键字，接受一个参数的构造函数可以用于以下的隐式转换：
* 将对象初始化为double值时
* 将double值赋给对象时
* 将double值传递给接受Stonewt参数的函数时
* 返回值被声明为Stonewt的函数试图返回double值时
* 在上述任意一种情况下，使用可转换为double类型的内置类型时。

当且仅当不存在二义性时，会进行最后一点所说的二步转换，如将int类型转换为double类型。
###转换函数
将类类型转换为某种类型时，必须使用特殊的C++运算符函数，转换函数。转换函数是用户定义的强制类型转换，它允许用户将类类型赋给另一种类型。

要转换为typename类型，需要使用这种形式的转换函数：
```operator typename();```
* 转换函数必须是类方法；
* 转换函数不能指定返回类型
* 转换函数不能有参数
#### 自动应用类型转换
对于
 ```C++
Stonewt popins(9,2.8);
double p_wt=popins;
```
使用了显式强制类型转换，假设省略了显式强制类型转换：
```cout<<"Poppins: "<<poppins<<" pounds.\n";```
如果只定义了double转换函数，编译器将接受这种隐式转换，因为只有一种转换可能。如果存在多种类型转换函数，编译器会认为程序中使用了二义性转换。
赋值语句同样类似：
```long gone=poppins;//ambiguous```
在C++中，int和double值都可以赋给long变量，只有删除两种转换函数之一，编译器才接受这条语句。

当类定义了两种或更多的转换时，仍然可以使用显式强制类型转换指出要使用哪个转换函数。

原则上说，最好使用显式转换，避免隐式转换，在C++98中，关键字explicit不能用于转换函数，但C++11消除了这种限制，可以在C++11中将转换运算符声明为显式的。
####实现加法的选择
要让double量和Stonewt量相加，有两种选择：
1.将```operator+(const Stonewt &,const Stonewt &)```函数定义为友元,让Stonewt(double)构造函数将double类型转换为Stonewt类型的参数。
2.将加法运算符重载为一个显式使用double类型参数的函数
```C++
Stonewt operator+(double x) //与Stonewt+double匹配
friend Stonewt operator(double x,Stonewt & s)//与double+Stonewt匹配
```
第一种方法依赖于隐式转换，使程序更简短，缺点是每次转换都需要调用转换构造函数，增加时间和内存的开销。第二种方法增加了一个显式匹配类型的函数，使程序较长，但运行速度较快。