面向对象编程（OOP）是一种设计程序的概念性方法，
下面是最重要的OOP特性：
抽象、封装和数据隐藏、多态、继承、代码的可重用性。

类是一种将抽象转换为用户定义类型的C++工具，它将
数据表示和操纵数据的方法组合成一个整洁的包。

类规范由两个部分组成：
类声明：以数据成员的方式描述数据部分，以成员函数的方式描述公有接口；
类方法定义：描述如何实现类成员函数。

由于隐藏数据是OOP的主要目标之一，因此数据项通常放在私有部分，组成类接口
的成员函数放在公有部分。不必在类声明中使用关键字private，因为这是
类对象的默认访问控制：
class World{
float mass; //private by default
char name[20]; //private by default
public:
void tellall(void);
...
};

类很像是包含成员函数以及public和private可见性标签的结构声明，
实际上C++对结构进行了拓展，使其具有与类相同的特性。它们唯一的区别是，
结构的默认访问类型是public，类为private。
C++程序员通常把结构限制为只表示纯粹的数据对象（被称为普通老式数据Plain Old Data,POD结构）。

创建类的第二部分，类方法定义，即为由类声明中的原型表示的成员函数提供代码。
成员函数定义与常规函数相似，但是有两个特殊特征：
定义成员函数时，使用作用域解析符：：来标识函数所属的类；
成员函数可用访问类的private组件；

成员函数具有类作用域(class scope)，类中的成员函数不必使用::就可以使用同一个类的方法。

多个成员函数修改数据成员的值，不应编写计算代码多次，而应该让每个成员函数都
调用set_data()函数，且可以将set_data()声明为私有成员函数。
这种方法既可以省去许多输入代码的工作，节省空间，还可以确保
多个成员函数执行的计算完全相同，修订计算代码时只需更改一处即可。

定义位于类声明中的函数自动成为内联函数，类声明外只需在定义成员函数时使用inline限定符即可。
通常可以将短小的成员函数作为内联函数，如set_data()函数,showdata()函数。

内联函数的规则要求每个在使用它们的文件中都对其进行定义，确保内联定义对所有文件
都可用的方法是，将内联定义放在定义类的头文件中。

声明类变量：
Stock kate,joe;
这将创建两个Stock类对象，通过成员运算符使用对象的成员函数：kate.show();

所创建的每个新对象都有自己的存储空间，用于存储其内部变量和类成员，
但同一个类的所有对象共享同一组类方法，即每种方法只有一个副本。
在OOP中，调用成员函数被称为发送消息，因此将同样的消息发送给
两个不同的对象将调用同一个方法。

一段经典的总结，详见p287，10.2.6处。

不能像结构那样初始化类，因为类的数据成员是私有的，因此需要设计
合适的成员函数才能成功的将对象初始化，C++提供了特殊的成员函数——类构造函数，
在创建对象时，自动进行初始化，将值赋给它们的数据成员。

构造函数没有返回值，不声明类型。

构造函数的参数表示的不是类成员，而是赋给类成员的值，因此参数不能与类成员相同。
可以用带有默认参数的构造函数，只设置部分成员，其它成员使用默认值。

C++提供两种使用构造函数来初始化对象的方式，第一种是显式的调用构造函数(calls constructor explicitly)：
Stock food=Stock("Cabbage",250,1.25);
另一种是隐式调用构造函数(calls constructor implicitly)：
Stock garment("Furry Mason",50,2.5);
每次创建类对象C++都会使用类构造函数，包括用new动态分配内存：
Stock *pstock=new Stock("Games",18,19.0);
这种情况下对象没有名称，但可以用指针来管理该对象。

默认构造函数没有参数，如果程序中没有提供任何构造函数，则编译器
会为程序定义一个默认构造函数；否则，必须自己提供默认构造函数。
原因是C++程序会使用默认构造函数来创建未被初始化的对象。

默认构造函数可以没有任何参数：
Stock::Stock() //default constructor
{
company="no name";
shares=0;
share_val=0.0;
total_val=0.0
}
如果默认构造函数有参数，则必须给所有参数都提供默认值：
Stock(const string & co="Error",int n=0,double pr=0.0);
使用以上方式创建了默认构造函数后，便可以声明对象变量，而不进行显式初始化：
Stock first; //calls default constructor implicitly
Stock first=Stock(); //calls it explicitly
Stock *prelief=new Stock; //calls it implicitly
隐式调用默认构造函数时，不要使用圆括号，例如：Stock first();表示first()是一个返回Stock对象的函数。

用构造函数创建对象后，程序负责跟踪该对象，对象过期时，程序
将自动调用析构函数完成清理工作，例如如果构造函数用new分配内存，
则析构函数将使用delete释放这些内存。

析构函数的名称是类名前加上~。和构造函数一样，析构函数没有返回值和声明类型，
与构造函数不同的是，析构函数没有参数。因此原型必须是像这样的：
Stock::~Stock(){}
通常不应再代码中显式的调用析构函数。
如果创建的是静态存储对象，则析构函数在程序结束时自动调用；
如果创建的是自动存储对象，则析构函数将在程序执行完定义它的代码块时自动调用；
如果对象通过new创建的，它驻留在堆内存中，当使用delete时析构函数被自动调用；
程序可以创建临时对象以完成特定的操作，这种情况下程序将在结束使用该对象时自动调用析构函数。

自动变量将在程序退出其定义所属代码块时消失。

对于显式的调用构造函数，如Stock stock1=Stock("Cabbage",250,1.25);
C++允许编译器使用两种方式执行，第一种的行为和隐式调用完全一样，
第二种允许调用构造函数创建一个临时对象，然后把该对象的值复制到stock1中，
并丢弃它，使用这种方式编译器将为临时对象调用析构函数。
（注：隐式调用实例Stock stock2("Smart",12,20.0);)

可以将一个对象的值赋给同类型的另一个对象，与给结构赋值一样，在默认情况下，
给类对象赋值时，将把源对象的每个数据成员复制到目标对象中相应的数据成员中。

构造函数不仅可以用于初始化新对象，也可以用于给已有对象赋值：
stock1=Stock("foods",10,50.0)；
这种赋值语句总是在赋值前先创建一个临时对象，然后再调用构造函数，
再将其内容复制给stock1来实现的，随后程序调用析构函数，以删除该临时对象。

由于自动变量放在栈中，根据后进先出（LIFO）规则，最后创建的对象将
最先被删除，最先创建的对象最后被删除。

对于Stock stock1=stock2;这种赋值初始化语句，将会调用拷贝构造函数，
如果用户没有定义拷贝构造函数，编译器会自动生成一个拷贝构造函数，
用户自己定义的构造函数不会被调用。

C++11列表初始化：
Stock hot={"Plus"};
Stock temp {};
第一个声明将使用带有默认参数的构造函数，第二个声明将使用默认构造函数创建对象temp。
C++11还提供了名为std::initialize_list的类，可将其用作函数参数的类型，
这个类可以表示任意长度的列表，只要所有列表项的类型都相同。

const对象不能被常规函数调用，因为不能确保调用对象不被修改，
需要一种保证函数不会修改调用对象的语法：
void show() const;//promises not to change invoking object
void Stock::show() const //promises not to change invoking object
以这种方式声明和定义的类被称为const成员函数，只要类方法不修改调用对象，
就应将其声明为const。

接受一个参数的构造函数允许使用赋值语法将对象初始化为一个值：
Classname object=value；
这种特性可能导致问题，可以关闭。

每个成员函数包括构造函数和析构函数都有一个this指针，this指针指向调用对象，
this是对象的地址，对象本身是*this，成员函数中使用数据成员data，实际上是
this->data的简写。

可以用构造函数初始化数组元素，在这种情况下，必须为每个元素调用构造函数：
Stock stocks[10]={
Stock("NanoSmart",12.5,20),
Stock(),
Stock("Monolithic",130,3.25),
};
上述代码使用不同参数类型的构造函数初始化stocks[0],stocks[1],stocks[2],
由于该声明只初始化了数组的部分元素，余下的7个元素将使用默认构造函数进行初始化。

C++的enum工具提供了一种创建符号常量的方式，这种方式可以替代const，标准语法为：
enum spectrum{red,orange,yellow};
spectrum是新类型的名称，被称为枚举（enumeration），red，orange等作为符号常量，
它们对应整数值0~2，这些常量叫做枚举量（enumerator)，默认情况下将整数值从0开始
依次赋给枚举量，可以通过显式的指定整数值来覆盖默认值。
可以用枚举名声明这种类型的变量：spectrum band;
不进行强制类型转换时，只能将定义枚举时使用的枚举量赋给这种枚举的变量，比如0~2，
对于枚举只定义了赋值运算符，没有定义算术运算。

枚举量是整型，可以提升为int类型，但int类型不能自动转换为枚举类型：
int color=blue; //valid,spectrun type promoted to int
band=3; //invalid,int not converted to spectrum
color=3+red; //valid,red converted to int
将3直接赋给band将导致类型错误，但spectrum（3）赋给band
是可以的，因为它将int类型强制转换为spectrum类型。

可以使用赋值运算符显式的设置枚举量的值：
enum {zero,null=0,one,numero=1};
指定的值必须是整数，可以只显式的定义其中一些枚举量的值，
这里zero在默认情况下为0，后面没有初始化的枚举量的值将比其前面的
枚举量大1，因此one的值为1，可以创建多个值相同的变量。

/*每个枚举都有取值范围（range），C++现在通过强制类型转换，
可以将取值范围中的任何整数值赋给枚举变量，即使这个值不是枚举值。
取值范围是首先找出枚举量的最大值，找到大于这个最大值的最小的2的幂，
将它减1，便是取值范围的上限，如最大枚举值是101，取值上限就是127；
计算下限，首先找到枚举量的最小值，如果它不小于0，则取值范围下限为0，
否则采用与寻找上限方式相同的方式但加上负号，如最小枚举值为-6，下限就是-7。
如enum bits{one=1,two=2,eight=8};bits myflag;则myflag=bits(6);这样的代码是合法的。*/
实测发现，enum类型的取值范围是有符号int类型的最大和最小值。

C++11扩展了枚举，增加了作用域内枚举（scoped enumeration)。
传统的枚举在两个枚举中定义同名的枚举量会发生冲突，因为它们位于
相同的作用域内，C++11增加了一种新枚举，其枚举量的作用域为类：
enum class egg{Small,Medium,Large};
也可以用关键字struct代替class，无论哪种，都需要使用枚举名限定枚举量：
egg choice=egg::Large;
C++11还提高了作用域内枚举的安全性，它不能隐式的转换为整型，
而常规枚举可以。但可以进行显式的类型转换。

创建一个由所有对象共享的常量很有用，但是
声明类只描述了对象的形式，没有创建对象，因此在创建对象前
将没有用于存储值的空间，有两种方式可以实现这个目标：
在类中声明一个枚举，它的作用域是整个类，因此可以用
枚举为整型常量提供类作用域的符号名称：
class Bakery
{
enum {Months=12};
double consts[Months];
...
}
这里使用枚举只是为了创建符号常量，因此不需要提供枚举名。
用这种方式声明枚举不会创建类数据成员，在类作用域的代码中
遇到Months时，编译器会用12来替换它。
另一种在类中定义常量的方式是使用关键字static：
class Bakery
{
static const int Months=12;
double costs[Months];
...
}
这将创建一个常量Months，它与静态常量存储在一起，而不是存储在对象中。
因此只有一个Months常量，被所有Bakery对象共享。在C++98中，这种方法
只能声明值为整数或枚举的静态常量，不能存储double常量，C++11消除了这种限制。

类很适合描述ADT(abstract data type,抽象数据类型）,公有成员函数接口提供了ADT
描述的服务，类的私有部分和类方法的代码提供了实现，这些实现对类的客户隐藏。
ADT以通用的方式描述数据类型，而没有引入语言或实现细节。

例如通过使用栈，可以执行操作：
创建空栈；
将数据项添加到栈顶（push,压入）；
从栈顶删除数据项(pop,弹出）；
查看栈是否填满；
查看栈是否为空；
可以将上述描述转换为一个类声明，其中公有函数提供了表示栈操作的接口，而
私有数据成员负责存储栈数据。
私有部分必须表明数据存储的方式，例如可以用常规数组，动态分配数组或高级数据结构如链表，
然而公有接口应隐藏数据表示，以通用的术语表达，如创建栈，压入，弹出等。
具体实例见它处。