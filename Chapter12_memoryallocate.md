# 第十二章 类和动态内存分配
本章介绍如何对类使用new和delete以及如何处理由于使用动态内存引起的问题。通常，最好在程序运行时，而不是编译时，决定内存分配。
##动态内存和类
通过设计String类来深入了解new、delete和静态类成员的工作原理。
```C++
class StringBad{
    char * str;
    int len;
    static int num_strings;
    public:
    ...
}
```
这个类声明里，使用char指针而不是char数组表示姓名，意味着类声明本身没有为字符串分配存储空间，而是在构造函数里用new分配空间，避免了在声明里预定义字符串的长度。
另外，字符串并不是保存在对象中，而是单独保存在堆内存中，对象仅保留了char指针指出去哪里查找字符串的信息。
其次，将num_strings成员声明为静态存储类，静态类成员有一个特点：**无论创建了多少个对象，程序都只创建一个静态类变量副本。**，也就是说，类的所有成员共享同一个静态成员。
注意，**不能在类声明里初始化静态成员变量，因为声明描述了如何分配内存，但并不分配内存，除非静态数据成员为const整数类型或枚举型。** 可以在类声明之外用单独的语句进行初始化，因为静态成员是单独存储的，不是对象的组成部分。
```int StringBad::num_strings=0;```
初始化语句指出了类型，使用了作用域运算符，但没有使用关键字static。初始化不能在类声明文件中进行，要在包含类方法的文件中进行。

在构造函数中使用new分配内存时，必须在相应的析构函数中使用delete释放内存，如果使用new[]分配内存，则应使用delete[]释放内存。

当使用一个对象初始化另一个对象时，编译器将自动生成复制构造函数。
```StringBad sailor=sports;```
* 用基本类型变量初始化对象时，将调用只接受一个参数的构造函数，会创建一个临时对象；
* 可以用显式或隐式调用构造函数来初始化，编译器可能会创建一个临时对象；
* 调用构造函数赋值给对象时，必定产生一个临时对象；

具体来说，C++自动提供了如下的成员函数：
* 默认构造函数，如果没有定义构造函数；
* 默认析构函数，如果没有定义；
* 默认复制构造函数，如果没有定义；
* 赋值运算符，如果没有定义；
* 地址运算符，如果没有定义；

如果将一个对象赋给另一个对象，将会隐式调用复制构造函数和赋值运算符，然后隐式地址运算符返回调用对象的地址（即this指针的值）。
另外，C++11提供了两个特殊成员函数：移动构造函数(move constructor),移动赋值运算符(move assignment operator)，将在18章讨论。
### 复制构造函数
复制 构造函数用于将一个对象复制到新创建的对象中，也就是说，它用于初始化过程（包括按值传递参数），而不是常规的赋值过程。类的复制构造函数原型如下：
```Class_name(const Class_name &);```
它接受一个指向类对象的常量引用作为参数。
#### 何时调用复制构造函数
* 最常见的情况是将新对象显式初始化为现有的对象时，例如motto是一个StringBad对象，下面四种声明都将调用复制构造函数：
 ```C++
StringBad ditto(motto); //calls StringBad(const StringBad &)
StringBad metoo=motoo; //calls StringBad(const StringBad &)
StringBad also=StringBad(motto);//calls StringBad(const StringBad &)
StringBad * pStringBad=new StringBad(motto);//calls StringBad(const StringBad &)
```
中间两种声明可能会使用复制构造函数直接创建metoo和also，也可能使用复制构造函数生成一个临时对象，然后将临时对象的内容赋给metoo和also，这取决于编译器的实现。
最后一种声明使用motto初始化一个匿名对象，并将新对象的地址赋给指针。

* 每当程序生成了对象副本时，具体地说，当函数按值传递对象或函数返回对象时，都将使用复制构造函数。按值传递相当于创建原始变量的一个副本。由于按值传递将调用复制构造函数，因此应该按引用传递对象，可以节省时间和内存。
* 编译器生成临时对象时，也将使用复制构造函数，例如将3个Vector对象相加时，编译器可能生成临时的Vector对象保存中间结果。何时生成临时对象取决于编译器。
#### 默认复制构造函数的功能
默认的复制构造函数逐个复制非静态成员的值（**成员复制也称为浅复制**），如果成员本身就是类对象，则将使用这个类的复制构造函数来复制成员对象。静态成员不受影响，因为它们属于整个类，而不是各个对象。

如果类中包含一个每当创建新对象count++的静态数据成员，应该提供一个显式的复制构造函数来处理计数问题。

**默认构造函数会复制指针变量的值，也就是说有两个指针指向同一个内存，当其中一个对象的析构函数用delete释放这个内存后，另一个指针将指向一个未知的内存空间，可能导致严重的后果。**

解决类设计的这种问题的方法是**深度复制(deep copy)**，也就是说，复制构造函数应当复制指向的数据，而不是指针。

如果类中包含了使用new初始化的指针成员，应当定义一个复制构造函数，进行深度复制，而不是成员复制、浅复制。
#### 赋值运算符
* 将已有对象赋给另一个对象时，将使用重载的赋值运算符。
* 初始化对象时，并不一定使用赋值运算符。初始化总是会调用复制构造函数，使用=运算符时也允许调用赋值运算符，即复制构造函数创建一个临时对象再通过赋值将临时对象复制到新对象中。

如何编写赋值运算符：
* 目标对象可能引用已经分配过内存的数据，所以函数应使用delte[]释放这些数据；
* 函数应当避免将对象赋给自身，否则在给对象重新赋值之前，释放内存操作可能删除对象的内容。
* 函数返回一个指向调用对象的引用
```C++
StringBad & StringBad::operator=(const StringBad & st)
{
    if(this==&st) //object assigned to itself
    return *this;//all done
    delete [] str;//free old string
    len=st.len;
    str=new char [len+1];//get space for new string
    std::strcpy(str,st.str);//copy the string
    return *this; //return reference to invoking object
}
```
代码首先检查自我复制，它通过查看复制运算符右边的地址与接收对象的地址是否相同来完成的。如果地址不同，函数将释放str指向的内存，这是为了防止内存被浪费掉。接下来的操作与复制构造函数相同，为新字符串分配足够的内存空间，然后将赋值运算符右边的对象中的字符串复制到新的内存单元中。
#### 空指针
修订后的默认构造函数：
```C++
String::String
{
    len=0;
    str=new char[1];
    str[0]='\0';//default string
}
```
```str=new char[1];```与```str=new char;```分配的内存量相同，但是前者可以与类析构函数的```delete [] str;```兼容，后者不兼容。
而delete[]与使用new初始化的指针和空指针都兼容，因此
```str[0]='\0';```可修改为```str=0;```
对于以其它形式初始化的指针，使用delete[]是未定义行为，结果未知。
**在C++98中，字面值0有两个含义：数字0或者空指针；有些程序员使用(void *)0标识空指针（空指针本身内部可能不是0），还有些程序员使用C语言宏NULL；C++11引入关键字nullptr用于表示空指针，即str=nullptr;。***
#### 中括号运算符
在C++中，两个中括号组成中括号运算符，可以使用方法operator[]()重载该运算符。对于中括号运算符，一个操作数位于第一个中括号的前面，另一个操作数位于两个中括号之间。
下面是对该方法的简单实现：
```C++
char & String::operator[](int i)
{
    return str[i];
}
```
假设opera是一个String对象，语句```cout<<opera[4];```将被转换为```cout<<opera.operator[](4);```，返回值是```opera.str[4]```，通过这种方式，公有方法能够访问私有数据。
将返回类型声明为char &，便可以赋值：
```C++
String means("might");
means[0]='r';
```
代码的最后一行访问的是私有数据，但是由于operator[]()的返回值是引用，因此能够修改数组的内容。
假如有一个常量对象```const String answer["futile"];```，就不能使用公有方法访问，因为无法确保不修改数据，因此需要提供一个仅供const String对象使用的版本：
```C++
const char & String::operator[](int i) const
{
    return str[i];
}
```
有了上述定义，就可以读写常规对象，对于常量对象只能读不能写入修改。
####静态成员函数
可以将函数成员声明为静态的，函数声明必须包含关键字static，如果函数定义是独立的，函数定义不能包含static。
这样的静态成员函数，
* 不能通过对象调用静态成员函数。静态成员函数不能使用this指针。如果静态函数在公有部分声明，可以使用类名加作用域解析符来调用它。
* 静态成员函数只能使用静态数据成员。因为它不与特定的对象相关联。例如静态方法How_many()可以访问静态成员num_string，但不能访问str和len。
* 可以使用静态成员函数设置类级(classwide)标记，以控制某些接口的行为，例如控制显示类内容的方法所使用的格式。
