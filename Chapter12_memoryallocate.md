# 第十二章 类和动态内存分配
本章介绍如何对类使用new和delete以及如何处理由于使用动态内存引起的问题。通常，最好在程序运行时，而不是编译时，决定内存分配。
##动态内存和类
通过设计String类来深入了解new、delete和静态类成员的工作原理。
```C++
class StringBad{
    char * str;
    int len;
    static int num_strings;
    public:
    ...
}
```
这个类声明里，使用char指针而不是char数组表示姓名，意味着类声明本身没有为字符串分配存储空间，而是在构造函数里用new分配空间，避免了在声明里预定义字符串的长度。
另外，字符串并不是保存在对象中，而是单独保存在堆内存中，对象仅保留了char指针指出去哪里查找字符串的信息。
其次，将num_strings成员声明为静态存储类，静态类成员有一个特点：**无论创建了多少个对象，程序都只创建一个静态类变量副本。**，也就是说，类的所有成员共享同一个静态成员。
注意，**不能在类声明里初始化静态成员变量，因为声明描述了如何分配内存，但并不分配内存，除非静态数据成员为const整数类型或枚举型。** 可以在类声明之外用单独的语句进行初始化，因为静态成员是单独存储的，不是对象的组成部分。
```int StringBad::num_strings=0;```
初始化语句指出了类型，使用了作用域运算符，但没有使用关键字static。初始化不能在类声明文件中进行，要在包含类方法的文件中进行。

在构造函数中使用new分配内存时，必须在相应的析构函数中使用delete释放内存，如果使用new[]分配内存，则应使用delete[]释放内存。

当使用一个对象初始化另一个对象时，编译器将自动生成复制构造函数。
```StringBad sailor=sports;```
* 用基本类型变量初始化对象时，将调用只接受一个参数的构造函数，会创建一个临时对象；
* 可以用显式或隐式调用构造函数来初始化，编译器可能会创建一个临时对象；
* 调用构造函数赋值给对象时，必定产生一个临时对象；

具体来说，C++自动提供了如下的成员函数：
* 默认构造函数，如果没有定义构造函数；
* 默认析构函数，如果没有定义；
* 默认复制构造函数，如果没有定义；
* 赋值运算符，如果没有定义；
* 地址运算符，如果没有定义；

如果将一个对象赋给另一个对象，将会隐式调用复制构造函数和赋值运算符，然后隐式地址运算符返回调用对象的地址（即this指针的值）。
另外，C++11提供了两个特殊成员函数：移动构造函数(move constructor),移动赋值运算符(move assignment operator)，将在18章讨论。
### 复制构造函数
复制 构造函数用于将一个对象复制到新创建的对象中，也就是说，它用于初始化过程（包括按值传递参数），而不是常规的赋值过程。类的复制构造函数原型如下：
```Class_name(const Class_name &);```
它接受一个指向类对象的常量引用作为参数。
#### 何时调用复制构造函数
* 最常见的情况是将新对象显式初始化为现有的对象时，例如motto是一个StringBad对象，下面四种声明都将调用复制构造函数：
 ```C++
StringBad ditto(motto); //calls StringBad(const StringBad &)
StringBad metoo=motoo; //calls StringBad(const StringBad &)
StringBad also=StringBad(motto);//calls StringBad(const StringBad &)
StringBad * pStringBad=new StringBad(motto);//calls StringBad(const StringBad &)
```
中间两种声明可能会使用复制构造函数直接创建metoo和also，也可能使用复制构造函数生成一个临时对象，然后将临时对象的内容赋给metoo和also，这取决于编译器的实现。
最后一种声明使用motto初始化一个匿名对象，并将新对象的地址赋给指针。

* 每当程序生成了对象副本时，具体地说，当函数按值传递对象或函数返回对象时，都将使用复制构造函数。按值传递相当于创建原始变量的一个副本。由于按值传递将调用复制构造函数，因此应该按引用传递对象，可以节省时间和内存。
* 编译器生成临时对象时，也将使用复制构造函数，例如将3个Vector对象相加时，编译器可能生成临时的Vector对象保存中间结果。何时生成临时对象取决于编译器。
#### 默认复制构造函数的功能
默认的复制构造函数逐个复制非静态成员的值（**成员复制也称为浅复制**），如果成员本身就是类对象，则将使用这个类的复制构造函数来复制成员对象。静态成员不受影响，因为它们属于整个类，而不是各个对象。

如果类中包含一个每当创建新对象count++的静态数据成员，应该提供一个显式的复制构造函数来处理计数问题。

**默认构造函数会复制指针变量的值，也就是说有两个指针指向同一个内存，当其中一个对象的析构函数用delete释放这个内存后，另一个指针将指向一个未知的内存空间，可能导致严重的后果。**

解决类设计的这种问题的方法是**深度复制(deep copy)**，也就是说，复制构造函数应当复制指向的数据，而不是指针。

如果类中包含了使用new初始化的指针成员，应当定义一个复制构造函数，进行深度复制，而不是成员复制、浅复制。
#### 赋值运算符
* 将已有对象赋给另一个对象时，将使用重载的赋值运算符。
* 初始化对象时，并不一定使用赋值运算符。初始化总是会调用复制构造函数，使用=运算符时也允许调用赋值运算符，即复制构造函数创建一个临时对象再通过赋值将临时对象复制到新对象中。

如何编写赋值运算符：
* 目标对象可能引用已经分配过内存的数据，所以函数应使用delte[]释放这些数据；
* 函数应当避免将对象赋给自身，否则在给对象重新赋值之前，释放内存操作可能删除对象的内容。
* 函数返回一个指向调用对象的引用。通过返回一个对象，函数可以像常规赋值操作那样，连续进行赋值。
```C++
StringBad & StringBad::operator=(const StringBad & st)
{
    if(this==&st) //object assigned to itself
    return *this;//all done
    delete [] str;//free old string
    len=st.len;
    str=new char [len+1];//get space for new string
    std::strcpy(str,st.str);//copy the string
    return *this; //return reference to invoking object
}
```
代码首先检查自我复制，它通过查看复制运算符右边的地址与接收对象的地址是否相同来完成的。如果地址不同，函数将释放str指向的内存，这是为了防止内存被浪费掉。接下来的操作与复制构造函数相同，为新字符串分配足够的内存空间，然后将赋值运算符右边的对象中的字符串复制到新的内存单元中。
#### 空指针
修订后的默认构造函数：
```C++
String::String
{
    len=0;
    str=new char[1];
    str[0]='\0';//default string
}
```
```str=new char[1];```与```str=new char;```分配的内存量相同，但是前者可以与类析构函数的```delete [] str;```兼容，后者不兼容。
而delete[]与使用new初始化的指针和空指针都兼容，因此
```str[0]='\0';```可修改为```str=0;```
对于以其它形式初始化的指针，使用delete[]是未定义行为，结果未知。
**在C++98中，字面值0有两个含义：数字0或者空指针；有些程序员使用(void \*)0标识空指针（空指针本身内部可能不是0），还有些程序员使用C语言宏NULL（一个被定义为0的符号常量）；C++11引入关键字nullptr用于表示空指针，即str=nullptr;。***
#### 中括号运算符
在C++中，两个中括号组成中括号运算符，可以使用方法operator[]()重载该运算符。对于中括号运算符，一个操作数位于第一个中括号的前面，另一个操作数位于两个中括号之间。
下面是对该方法的简单实现：
```C++
char & String::operator[](int i)
{
    return str[i];
}
```
假设opera是一个String对象，语句```cout<<opera[4];```将被转换为```cout<<opera.operator[](4);```，返回值是```opera.str[4]```，通过这种方式，公有方法能够访问私有数据。
将返回类型声明为char &，便可以赋值：
```C++
String means("might");
means[0]='r';
```
代码的最后一行访问的是私有数据，但是由于operator[]()的返回值是引用，因此能够修改数组的内容。
假如有一个常量对象```const String answer["futile"];```，就不能使用公有方法访问，因为无法确保不修改数据，因此需要提供一个仅供const String对象使用的版本：
```C++
const char & String::operator[](int i) const
{
    return str[i];
}
```
有了上述定义，就可以读写常规对象，对于常量对象只能读不能写入修改。
#### 静态成员函数
可以将函数成员声明为静态的，函数声明必须包含关键字static，如果函数定义是独立的，函数定义不能包含static。
这样的静态成员函数，
* 不能通过对象调用静态成员函数。静态成员函数不能使用this指针。如果静态函数在公有部分声明，可以使用类名加作用域解析符来调用它。
* 静态成员函数只能使用静态数据成员。因为它不与特定的对象相关联。例如静态方法How_many()可以访问静态成员num_string，但不能访问str和len。
* 可以使用静态成员函数设置类级(classwide)标记，以控制某些接口的行为，例如控制显示类内容的方法所使用的格式。
#### 进一步重载赋值运算符
对于
```C++
String name;
char temp[40];
cin.getline(temp,40);
name=temp;
```
程序会把只有一个参数的构造函数作为转换函数，创建一个临时String对象，然后使用重载=运算符函数将临时对象中的信息复制到name对象中，然后程序调用~String()析构函数删除临时对象。

为了提高效率，最简单的办法是重载赋值运算符，让它能够直接使用常规字符串，这样就不用创建和删除临时对象了。
```C++
String & String::operator=(const char * s)
{
    delete [] str;
    len=std::strlen(s);
    str=new char[len+1];
    std::strcpy(str,s);
    return *this;
}
```
#### 重载>>运算符 
重载>>运算符提供了一种将键盘输入行读入String对象的简单方法，它假定输入的字符数不多于String::CINLIM的字符数，并丢弃多余的字符。在if条件下，如果由于某些原因，如到达文件尾或读取的是一个空行导致输入失败，istream对象的值将置为false。
```C++
istream & operator>>(istream & is,String & st)
{
    char temp[String::CINLIM];
    is.get(temp,String::CINLIM);
    if(is)
    st=temp;
    while(is&&is.get()!='\n')
    continue;
    return is;
}
```
较早的```get(char*,int)```版本在读取空行后，返回的值不为false。对于这些版本，如果读取了一个空行，则字符串中第一个字符将是一个空字符。可以使用如下的代码：
```C++
if(!cin&&temp[0]=='\0')//empty line?
break;  //i not increments
```
上述代码可以用在cin.get(char*,int)函数后，这个函数会返回istream对象，因此能够检测是否读取到空行。
```C++
cin.get(temp,MaxLen)
while(cin&&cin.get()!='\n')
continue;
```
上述代码可以在读取到输入上限后，用while循环丢弃多余的字符。cin.get()函数的作用是读取一个字符，并返回int整型，表示它的ASCII码。
###在构造函数中使用new的注意事项
* 如果在构造函数中使用new初始化指针成员，应在析构函数中使用delete。
* new和delete必须相互兼容。new对应delete，new[]对应delete[]。
* 如果有多个构造函数，必须以相同的方式使用new，要么都带中括号，要么都不带。因为只有一个析构函数，所有构造函数都要兼容它。但是在构造函数中将指针初始化为空（0或C++11的nullptr）不受影响，因为无论带中括号还是不带的delete都可以用于空指针。
* 应当定义一个复制构造函数，通过深度复制将一个对象初始化为另一个对象。具体地说，复制构造函数应分配足够的空间存储复制的数据并复制数据，而不是只复制数据的地址。还应该更新所有受影响的静态类成员。
* 应当定义一个赋值运算符，通过深度复制将一个对象复制给另一个对象。应当检查是否自我赋值，释放内存，复制数据而不是地址，并返回一个对象的引用。
### 有关返回对象的说明

1. 返回指向const对象的引用。它可以提高效率，减少直接返回对象时调用复制构造函数造成的内存开销。但是引用指向的对象应该在调用函数执行时已经存在。

至于返回类型是const的原因：接收的参数如果被声明为const引用，则返回类型必须是const才匹配。比如一个返回最大值的类方法，传入两个const引用对象后经过比较返回其中一个，返回类型必须也是const引用才可以。

2. 返回指向非const对象的引用。它可以用于重载赋值运算符和重载与cout一起使用的<<运算符。前者的返回值需要用于连续赋值，后者用于cout的串接输出，由于ostream类没有公有的复制构造函数，要避免直接返回ostream对象。
3. 返回对象。当被返回的对象是函数中的局部变量时，不应按引用返回，因为函数执行完毕后局部变量将调用其析构函数，引用的对象不复存在。被重载的算术运算符通常属于这一类，它可能直接返回一个算术表达式，表达式计算的结果被存储在临时对象中。这种情况下，无法避免调用复制构造函数造成的内存开销。
4. 返回const对象。假设net,force1和force2是Vector类对象，对于Vector::operator+()函数，
```C++
net=force1+force2;
force1+force2=net;
cout<<(force1+force2=net).magval()<<endl;
```
这三种代码都能正常运行，因为复制构造函数将创建一个临时对象来表示返回值，表达式force1+force2的结果是一个临时对象，在语句1中，它被赋给net，在语句2、3中，net被赋给这个临时对象。使用完临时对象后，临时对象被丢弃。
为了避免这种行为可能引发的误用和滥用，可以将返回类型声明为const Vector，这样只有语句1合法，语句2，3是非法的。
### 使用指向对象的指针
通常，如果Class_name是类，value的类型为Type_name，则语句：
```C++
Class_name * pclass=new Class_name(value);
```
将调用构造函数```Class_name(Type_name)；```，或者```Class_name(const Type_name &);```，此外如果没有二义性，将可以发生由原型匹配导致的类型转换（如从int到double）。
而语句：
```C++
Class_name * ptr=new Class_name;
```
将调用默认构造函数。
#### 析构函数被调用的情形：
* 如果对象是动态变量，则当执行完定义该对象的代码块时，将调用该对象的析构函数。
* 如果对象是静态变量，则在程序结束时将调用对象的析构函数。
* 如果对象是用new创建的，则仅当显式使用delete删除对象时，才会调用析构函数。
#### 指针和对象的注意事项
* 使用常规表示法来声明指向对象的指针：
  ```String * glamour;```
* 可以将指针初始化指向已有的对象：
  ```String * first=&sayings[0];```
* 可以使用new来初始化指针，创建一个新的对象
  ```C++
  String * gleep=new String;
  //invokes default constructor
  String * favarite=new String(sayings[choice]);
  //invokes the String(const String &) constructor
  String * glop=new String("my my my");
  //invokes the String(const char *) constructor
  ```
* 可以使用->运算符通过指针访问类方法
  ```if(sayings[i].length<shortest->length)```
* 可以对对象指针应用解引用运算符*来获得对象。
  ```if(sayings[i]<*first)```
#### 使用定位new运算符给对象分配内存
使用new运算符创建一个512字节的缓冲区，然后使用定位new运算符在内存缓冲区中创建两个JustTesting对象：
```C++
#include<new>
const int BUF=512;
int main()
{
    char * buffer=new char[BUF];//get ablock of memory
    pc1=new (buffer) JustTesting;//place object in buffer
    pc3=new (buffer+sizeof(JustTesting)) JustTesting("Better Idea",6);
    pc3->~JustTesting();//destroy object to pointed to by p3
    pc1->~JustTesting();
    delete [] buffer;
} 
```
* 创建第二个对象时，要使用与第一个对象不同的内存单元，需要确保这两个内存单元不重叠，让指针pc3相对于pc1的偏移量为JustTesting对象的大小。
* delete不能与定位new运算符配合使用，**必须显式的为使用定位new运算符创建的对象使用析构函数。**
* 需要注意正确的删除顺序，对于使用定位new运算符创建的对象，应以与创建顺序相反的顺序进行删除，仅当所有对象都被销毁后，才能释放存储这些对象的缓冲区。
## 队列模拟
队列是一种抽象的数据类型ADT，可以存储有序的项目序列，新项目被添加在队尾，并可以删除队首的项目，与栈不同，栈在同一端进行添加和删除，是后进先出LIFO结构，而队列是先进先出FIFO的。
队列就像现实中排队一样，排在最前面的先走。
### 队列的特征
* 存储有序的项目序列
* 队列所能容纳的项目数有一定的限制
* 能够创建空序列
* 能够检查队列是否为空
* 能够检查队列是否是满的
* 能够在队尾添加项目
* 能够从队首删除项目
* 能够确定队列中的项目数
### 设计一个Queue类
需要确定如何表示队列数据。
* 一种方法是使用new动态分配一个数组，它包含所需的元素数，但是对于队列操作，数组不太合适，例如删除数组第一个元素后，需要将余下的所有元素向前一位。
* 链表可以很好的满足队列的要求。链表由节点序列构成，每一个节点都包含要保存在链表中的信息，以及一个指向下一个节点的指针。
#### 链表
* 在一个单向链表中，因为每个节点都只包含一个指向其它节点的指针，知道第一个节点的地址后，就可以沿指针找到后面的每一个节点。
* 通常链表最后一个节点的指针被设置为NULL或0，以指出后面没有节点了。
* 要跟踪链表，必须知道第一个节点的地址，可以让Queue类的一个数据成员指向链表的起始位置，就可以沿着节点链找到任何节点。
* 由于队列总是将新项目添加到队尾，因此包含一个指向最后一个节点的数据成员会更方便。还可以使用数据成员来跟踪队列可存储的最大项目数以及当前的项目数。
#### 嵌套结构与类
C++有一个特性：在类声明中声明的结构、类或枚举被称为是嵌套在类中，其作用域为整个类。这种声明不会创建数据对象，只是指定了可以在类中使用的类型。
如果声明是在类的私有部分进行的，则只能在这个类使用被声明的类型；如果声明是在类的公有部分进行的，则可以从类的外部通过作用域解析符使用被声明的类型。

