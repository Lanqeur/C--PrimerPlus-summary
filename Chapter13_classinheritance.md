# 第十三章 类继承
面向对象编程的主要目的之一的提供可重用的代码。
C++提供了比修改代码更好的方法来扩展和修改类，它能够从已有的类派生出新的类，而派生类继承了原有类（基类）的特征，包括方法。通过继承派生出来的类可以做到：
* 在已有类的基础上添加功能。
* 给类添加数据。
* 修改类方法的行为。

虽然可以通过复制原始类代码并对其修改完成工作，但继承机制只需提供新特性，**甚至不需要访问源代码就可以派生出类**。如果购买的类库只提供了类方法的头文件和编译后代码，仍可以使用库中的类派生出新的类，而且可以在不公开实现的情况下将自己的类分发给其他人，同时允许他们在类中添加新特性。
### 一个简单的基类
从一个类派生出另一个类时，原始类称为基类，继承类称为派生类。
对于TableTennisPlayer类的构造函数，使用成员初始化列表会比以下形式：
```C++
TableTennisPlayer::TableTennisPlayer(const string & fn,const string & ln,bool ht)
{
    firstname=fn;
    lastname=ln;
    hasTable=ht;
}
```
减少一个步骤，因为这种形式会先调用string的默认构造函数，再调用string的赋值运算符将firstname设置为fn，初始化列表直接使用string的复制构造函数将firstname初始化为fn。
### 派生一个类
将RatedPlayer类声明为从TableTennisPlayer类派生而来：
```C++
//RatedPlayer derives from the TableTennisPlayer base class
class RatedPlayer:public TableTennisPlayer
{
    private：
    unsigned int rating;//add a data member
    public:
    ...
};
```
冒号指出RatedPlayer类的基类，public指出TableTennisPlayer是一个公有基类，这被称为公有派生。派生类对象包含基类对象，使用公有派生，基类的公有成员将成为派生类的公有成员；基类的私有部分也将成为派生类的一部分，但只能通过基类的公有和保护方法访问。
RatedPlayer对象具有以下特征：
* 派生类对象存储了基类的数据成员（派生类继承了基类的实现）；
* 派生类对象可以使用基类的方法（派生类继承了基类的接口）；

还需要在派生类中添加：
* 派生类自己的构造函数；
* 根据需要添加额外的数据成员和成员函数；
### 派生类的构造函数
* 构造函数必须给新成员以及继承的成员提供数据。
* 派生类不能直接访问基类的私有成员，必须通过基类方法进行访问，例如RatedPlayer构造函数不能直接设置继承的成员，但可以使用基类构造函数。
* 创建派生对象时，程序首先创建基类对象。C++使用成员初始化列表语法完成这种工作。下述构造函数中，前两个使用成员初始化列表，第一个调用基类构造函数，第二个调用基类复制构造函数，第三个将调用基类的默认构造函数。
```C++
//invoking constructor
RatedPlayer::RatedPlayer(unsigned int r,const string & fn,const string & ln,bool ht):TableTennisPlayer(fn,ln,ht)
{
    rating=r;
}
//invoking copy constructor
RatedPlayer::RatedPlayer(unsigned int r,const TableTennisPlayer & tp):TableTennisPlayer(tp)
{
    rating=r;
}
//invoking default constructor
RatedPlayer::RatedPlayer(unsigned int r)
{
    rating=r;
}
```
RatedPlayer构造函数把实参传递给TableTennisPlayer构造函数，后者会创建一个嵌套TableTennisPlayer对象，并将数据存储在该对象中，然后程序进入RatedPlayer构造函数体，完成RatedPlayer对象的创建。
* 如果省略成员初始化列表，程序将使用默认的基类构造函数。因此除非真的要使用默认构造函数，否则应显式调用正确的基类构造函数。

有关派生类的要点：
1. 首先创建基类对象；
2. 派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数；
3. 派生类构造函数应初始化派生类新增的数据成员。
4. 释放对象的顺序与创建对象顺序相反，首先执行派生类的析构函数，然后自动调用基类的析构函数。
### 使用派生类
要使用派生类，程序必须能够访问基类声明。可以将这两种类的声明置于同一个头文件中，也可以将每个类放在独立的头文件里，但由于这两个类是相关的，所以将其类声明放在一起更合适。同样，这两个类的方法定义放在一起更合适。

派生类与基类的特殊关系：
* 派生类可以使用基类的公有方法；
* 可以将派生类对象赋给基类指针，基类引用，但基类指针和基类引用只能调用基类方法。在不进行显式转换的情况下，基类指针、基类引用就可以指向基类对象或派生类对象。
* 不可以将基类对象赋给派生类指针，派生类引用，因为为基类对象调用派生类方法是无效的。
* 对于形参为基类指针的函数，可以使用基类对象或派生类对象的地址作为实参。
* 引用的兼容性允许将基类对象初始化为派生类对象，实质上是调用复制构造函数将基类对象初始化为派生类对象内嵌的基类对象。
* 同理，可以将派生类对象赋给基类对象。
## 继承：is-a关系
* C++的公有继承，建立一种is-a关系，即派生类对象也是一个基类对象，可以执行基类对象的任何操作。is-a关系通常是不可逆的，比如说香蕉是水果，但是水果不是香蕉。
* 公有继承不建立has-a关系。这种关系可以看作是将一个对象作为另一个类的数据成员。
* 公有继承不能建立is-like-a关系。因为继承只能在基类的基础上添加属性，不能删除基类的某些属性而保留另一部分。但可以设计一个包含公有特征的类，然后在这个类的基础上定义相关的类。
* 公有继承不建立uses-a关系。但是可以使用友元函数来处理两类对象之间的通信。
## 多态公有继承
我们可能会希望同一个方法在派生类和基类中的行为是不同的，有多种形态，即多态。有两种机制可以实现多态公有继承：
* 在派生类重新定义基类的方法；
* 使用虚方法
### 使用虚方法
* 如果要在派生类中重新定义基类的方法，通常应将基类方法声明为虚的。
* 我们知道，基类的指针或引用可以指向基类对象或派生类对象，但是只能调用基类方法，但是如果使用关键字virtual，程序将根据对象类型而不是引用或指针的类型来选择方法版本，也就是说，一个指向派生类对象的基类指针或引用，将会调用派生类的方法而不是基类方法。
* 惯例上要为基类声明一个虚析构函数，这样做是为了确保释放派生对象时，按正确的顺序调用析构函数。
* 关键字virtual只用于类声明的方法原型中，不用于方法定义。

**在派生类的虚方法中，必须使用作用域解析符来调用基类方法。** 代码必须使用作用域解析符，否则会递归调用自身且不会终止。
对于派生类没有重新定义的方法，代码可以不必使用作用域解析符。

关于使用格式化方法将浮点值的输出模式设置为定点，即包含两位小数，最后将格式模式重置为调用前的状态，由于这个不及printf()方便，所以不再研究，具体实现可看403页程序清单13.8 。
#### 为何需要虚析构函数
对于基类指针指向派生类对象的情况，如果析构函数不是虚的，则将只调用基类的析构函数，但如果析构函数是虚的，将调用派生类的析构函数，然后自动调用基类的析构函数。因此，使用虚析构函数可以确保正确的析构函数序列被调用。