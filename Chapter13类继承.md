# 第十三章 类继承
面向对象编程的主要目的之一的提供可重用的代码。
C++提供了比修改代码更好的方法来扩展和修改类，它能够从已有的类派生出新的类，而派生类继承了原有类（基类）的特征，包括方法。通过继承派生出来的类可以做到：
* 在已有类的基础上添加功能。
* 给类添加数据。
* 修改类方法的行为。

虽然可以通过复制原始类代码并对其修改完成工作，但继承机制只需提供新特性，**甚至不需要访问源代码就可以派生出类**。如果购买的类库只提供了类方法的头文件和编译后代码，仍可以使用库中的类派生出新的类，而且可以在不公开实现的情况下将自己的类分发给其他人，同时允许他们在类中添加新特性。
### 一个简单的基类
从一个类派生出另一个类时，原始类称为基类，继承类称为派生类。
对于TableTennisPlayer类的构造函数，使用成员初始化列表会比以下形式：
```C++
TableTennisPlayer::TableTennisPlayer(const string & fn,const string & ln,bool ht)
{
    firstname=fn;
    lastname=ln;
    hasTable=ht;
}
```
减少一个步骤，因为这种形式会先调用string的默认构造函数，再调用string的赋值运算符将firstname设置为fn，初始化列表直接使用string的复制构造函数将firstname初始化为fn。
### 派生一个类
将RatedPlayer类声明为从TableTennisPlayer类派生而来：
```C++
//RatedPlayer derives from the TableTennisPlayer base class
class RatedPlayer:public TableTennisPlayer
{
    private：
    unsigned int rating;//add a data member
    public:
    ...
};
```
冒号指出RatedPlayer类的基类，public指出TableTennisPlayer是一个公有基类，这被称为公有派生。派生类对象包含基类对象，使用公有派生，基类的公有成员将成为派生类的公有成员；基类的私有部分也将成为派生类的一部分，但只能通过基类的公有和保护方法访问。
RatedPlayer对象具有以下特征：
* 派生类对象存储了基类的数据成员（派生类继承了基类的实现）；
* 派生类对象可以使用基类的方法（派生类继承了基类的接口）；

还需要在派生类中添加：
* 派生类自己的构造函数；
* 根据需要添加额外的数据成员和成员函数；
### 派生类的构造函数
* 构造函数必须给新成员以及继承的成员提供数据。
* 派生类不能直接访问基类的私有成员，必须通过基类方法进行访问，例如RatedPlayer构造函数不能直接设置继承的成员，但可以使用基类构造函数。
* 创建派生对象时，程序首先创建基类对象。C++使用成员初始化列表语法完成这种工作。下述构造函数中，前两个使用成员初始化列表，第一个调用基类构造函数，第二个调用基类复制构造函数，第三个将调用基类的默认构造函数。
```C++
//invoking constructor
RatedPlayer::RatedPlayer(unsigned int r,const string & fn,const string & ln,bool ht):TableTennisPlayer(fn,ln,ht)
{
    rating=r;
}
//invoking copy constructor
RatedPlayer::RatedPlayer(unsigned int r,const TableTennisPlayer & tp):TableTennisPlayer(tp)
{
    rating=r;
}
//invoking default constructor
RatedPlayer::RatedPlayer(unsigned int r)
{
    rating=r;
}
```
RatedPlayer构造函数把实参传递给TableTennisPlayer构造函数，后者会创建一个嵌套TableTennisPlayer对象，并将数据存储在该对象中，然后程序进入RatedPlayer构造函数体，完成RatedPlayer对象的创建。
* 如果省略成员初始化列表，程序将使用默认的基类构造函数。因此除非真的要使用默认构造函数，否则应显式调用正确的基类构造函数。

有关派生类的要点：
1. 首先创建基类对象；
2. 派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数；
3. 派生类构造函数应初始化派生类新增的数据成员。
4. 释放对象的顺序与创建对象顺序相反，首先执行派生类的析构函数，然后自动调用基类的析构函数。
### 使用派生类
要使用派生类，程序必须能够访问基类声明。可以将这两种类的声明置于同一个头文件中，也可以将每个类放在独立的头文件里，但由于这两个类是相关的，所以将其类声明放在一起更合适。同样，这两个类的方法定义放在一起更合适。

派生类与基类的特殊关系：
* 派生类可以使用基类的公有方法；
* 可以将派生类对象赋给基类指针，基类引用，但基类指针和基类引用只能调用基类方法。在不进行显式转换的情况下，基类指针、基类引用就可以指向基类对象或派生类对象。
* 不可以将基类对象赋给派生类指针，派生类引用，因为为基类对象调用派生类方法是无效的。
* 对于形参为基类指针的函数，可以使用基类对象或派生类对象的地址作为实参。
* 引用的兼容性允许将基类对象初始化为派生类对象，实质上是调用复制构造函数将基类对象初始化为派生类对象内嵌的基类对象。
* 同理，可以将派生类对象赋给基类对象。
## 继承：is-a关系
* C++的公有继承，建立一种is-a关系，即派生类对象也是一个基类对象，可以执行基类对象的任何操作。is-a关系通常是不可逆的，比如说香蕉是水果，但是水果不是香蕉。
* 公有继承不建立has-a关系。这种关系可以看作是将一个对象作为另一个类的数据成员。
* 公有继承不能建立is-like-a关系。因为继承只能在基类的基础上添加属性，不能删除基类的某些属性而保留另一部分。但可以设计一个包含公有特征的类，然后在这个类的基础上定义相关的类。
* 公有继承不建立uses-a关系。但是可以使用友元函数来处理两类对象之间的通信。
## 多态公有继承
我们可能会希望同一个方法在派生类和基类中的行为是不同的，有多种形态，即多态。有两种机制可以实现多态公有继承：
* 在派生类重新定义基类的方法；
* 使用虚方法
### 使用虚方法
* 如果要在派生类中重新定义基类的方法，通常应将基类方法声明为虚的。
* 我们知道，基类的指针或引用可以指向基类对象或派生类对象，但是只能调用基类方法，但是如果使用关键字virtual，程序将根据对象类型而不是引用或指针的类型来选择方法版本，也就是说，一个指向派生类对象的基类指针或引用，将会调用派生类的方法而不是基类方法。
* 惯例上要为基类声明一个虚析构函数，这样做是为了确保释放派生对象时，按正确的顺序调用析构函数。
* 关键字virtual只用于类声明的方法原型中，不用于方法定义。

**在派生类的虚方法中，必须使用作用域解析符来调用基类方法。** 代码必须使用作用域解析符，否则会递归调用自身且不会终止。
对于派生类没有重新定义的方法，代码可以不必使用作用域解析符。

关于使用格式化方法将浮点值的输出模式设置为定点，即包含两位小数，最后将格式模式重置为调用前的状态，由于这个不及printf()方便，所以不再研究，具体实现可看403页程序清单13.8 。
#### 为何需要虚析构函数
对于基类指针指向派生类对象的情况，如果析构函数不是虚的，则将只调用基类的析构函数，但如果析构函数是虚的，将调用派生类的析构函数，然后自动调用基类的析构函数。因此，使用虚析构函数可以确保正确的析构函数序列被调用。
## 静态联编和动态联编
将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编(binding)，在C++中，编译器必须查看函数参数以及函数名才能确定使用哪个函数，编译器可以在编译过程完成这种联编。
这种在编译过程中进行联编被称为静态联编(static binding)。然而虚函数的存在，使用哪一个函数是不能在编译时确定的，因为编译器不知道用户将选择哪种类型对象，所以编译器必须生成能够在程序运行时选择正确虚方法的代码，这种被称为动态联编(dynamic binding)。
### 指针和引用类型的兼容性
* 在C++中，动态联编与通过指针或引用调用方法有关。也可以说它是由继承控制的。一般来说，C++不允许将一种类型的地址赋给另一种类型的指针，也不允许一种类型的引用指向另一种类型。但是指向基类的引用或指针可以引用派生类对象，而不必进行显式类型转换。
* 将派生类引用或指针转换为基类引用或指针被称为向上强制转换(upcasting)，这使公有继承不需要进行显式类型转换，该规则是is-a关系的一部分。
* 相反的过程，将基类指针或引用转换为派生类指针或引用，称为向下强制转换(downcasting)。如果不使用显式类型转换，则向下强制转换是不允许的，原因是is-a关系通常是不可逆的。
* 对于使用基类引用或指针作为参数的函数调用，将进行向上转换。如果按值传递，会只将派生类对象的基类部分传递给函数，但是按指针或引用传递会发生隐式向上转换。
* 隐式向上强制转换使基类指针或引用可以指向基类对象或派生类对象，因此需要动态联编，C++使用虚成员函数满足这种需求。
### 虚成员函数和动态联编
* 如果在基类中没有将方法声明为虚的，则基类指针会根据指针类型调用基类方法。指针类型是在编译时已知的，因此编译器对非虚方法使用静态联编。
* 如果在基类中将方法声明为虚的，则基类指针会根据对象类型调用基类方法或派生类方法。通常只有在运行程序时才能确定对象的类型，所以编译器生成的代码将在程序执行时，根据对象类型调用相应的函数，因此编译器对虚方法使用动态联编。
#### 为什么有两种类型的联编
* 首先是效率。为使程序能够在运行阶段进行决策，必须采取一些方法跟踪基类指针或引用指向的对象类型，这增加了额外的处理开销。C++的指导原则是，不要为不使用的特性付出代价，仅当程序确实需要虚函数时，才使用它们。因此静态联编是C++的默认选择。
* 其次看概念模型。设计类时，可能包含一些不在派生类重新定义的成员函数，不该将其设置为虚函数。一方面效率更高，另一方面指出不要重新定义该函数。
#### 虚函数的工作原理
通常编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员包含一个指向函数地址的指针，这种数组称为虚函数表(virtual function table,vtbl)。例如，基类对象包含一个指针，该指针指向基类中所有虚函数的地址表，派生类对象将包含一个指向独立地址表的指针。
如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址；如果派生类没有重新定义虚函数，该vtbl将保存函数的原始版本的地址。
调用虚函数时，程序将查看存储在对象中的vtbl地址，然后转向相应的函数地址表，如果使用程序定义的第n个虚函数，则程序将使用数组第n个函数地址，并执行具有该地址的函数。
总之，使用虚函数在内存和执行速度上方面有一定的成本，包括：
* 每个对象都将增大，增大量为存储地址的空间；
* 对于每个类，编译器都创建一个虚函数表；
* 对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址。
#### 有关虚函数的注意事项
1. 构造函数不能是虚函数。创建派生类对象时，将调用派生类的构造函数，而不是基类的构造函数，不过派生类的构造函数会使用基类的一个构造函数。
2. 析构函数应当是虚函数，除非类不用做基类。即使基类不需要显式构造函数提供服务，也应提供虚析构函数，即使它不执行任何操作。
3. 友元不能是虚函数，因为友元不是类成员，只有成员才能是虚函数。
4. 如果派生类没有重新定义函数，将使用该函数的基类版本，如果派生类位于派生链中，则将使用最新的虚函数版本，例外的情况是基类版本是隐藏的。
5. 重新定义将隐藏方法。
在派生类中重新定义方法不会生成函数的重载版本，而是隐藏了基类版本。
如果派生类想要完全不使用基类的某个方法，可以把重新定义的方法放在私有部分，使该方法不能以公有的形式被使用。
如果想要保持基类和派生类的同名方法的接口一致性，即只改变方法的实现，不改变方法的原型，可以遵循以下两条经验规则：
* 如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针，这种特性被称为返回类型协变(covariance of return type)，因为允许返回类型随类类型变化而变化。
* 如果基类声明被重载了，则应在派生类中重新定义所有的基类版本。如果只重新定义一个版本，则另外两个版本将被隐藏，派生类对象无法使用它们。
* 如果不需要修改派生类方法，则新定义可以只调用基类版本：
```void Derive::show() const {Base::show();}```
## 访问控制：protected
关键字protected与private相似，在类外只能用公有类成员来访问protected部分中的类成员。它们之间的区别只有在基类派生的类中才会表现出来。
派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员。
**最好对类数据成员采用私有访问控制，不要使用保护访问控制；同时通过基类方法使派生类能够访问基类数据；对于成员函数来说，保护访问控制很有用，它让派生类能够访问类外不能使用的内部函数。**
## 抽象基类(abstract base class,ABC)
我们可以从有共同特性的两个事物中抽象出它们的共性，将这些共性放到一个ABC中。这样，便可以使用基类指针同时管理这两种对象。比如从圆Circle和椭圆Ellipse中抽象出基类BaseEllipse。
 ```C++
class BaseEllipse//abstract base class
{
    private:
    double x;
    double y;
    ...
    public:
    BaseEllipse(double x0=0,double y0=0):x(x0),y(y0){}
    virtual ~BaseEllipse(){}
    void Move(int nx,ny){x=nx;y=ny;}
    virtual double Area() const=0;//a pure virtual function
    ...
}
```
C++使用纯虚函数(pure virtual function)提供未定义实现的函数。纯虚函数声明的结尾处为=0。

**当类声明中包含纯虚函数时，不能创建该类的对象。** 因为包含纯虚函数的类只用做基类。

**要想成为ABC，必须包含至少一个纯虚函数。**

C++允许纯虚函数有定义，可以在原型中声明为纯虚函数，然后在实现文件中提供方法的定义。

抽象基类的派生类如Circle类和Ellipse类有时被称为具体(concrete)类，这表示可以创建这些类型的对象。

总之，ABC描述的是至少一个纯虚函数的接口，从ABC派生出的类将根据派生类的具体特征，使用常规虚函数来实现这种接口。

可以在ABC中声明保护方法，这些保护方法只负责返回私有数据成员的值，这样就实现了基类数据成员的只读访问。使得可以进一步定制每个派生类的方法。
### ABC理念
设计ABC之前，首先应开发一个模型，指出编程问题所需的类以及它们之间的相互关系。
一种学院派思想认为，如果要设计类继承层次，则只能将那些不会被用作基类的类设计为具体的类，这种方法的设计更清晰，复杂程度很低。
**可以将ABC看作一种必须实施的接口，ABC要求具体派生类覆盖它的纯虚函数————迫使派生类遵循ABC设置的接口规则。**
这种模式在基于组件编程模式中很常见，使用ABC使得组件设计人员能够制定接口约定，确保了从ABC派生的所有组件都至少支持ABC指定的功能。
## 继承和动态内存分配
### 第一种情况：派生类不使用new
假设基类使用动态内存分配，声明中会包含构造函数使用new时需要的特殊方法：析构函数、复制构造函数、重载赋值运算符。
从基类派生出的类不使用new，则派生类不需要定义显式的析构函数、复制构造函数、重载赋值运算符。
因为派生类的默认析构函数总是在执行完自身的代码后调用基类析构函数；类的默认复制构造函数会使用基类的显式复制构造函数复制派生类对象里的基类部分；对于赋值运算符同理，类的默认赋值运算符将自动使用基类的赋值运算符来对基类组件进行赋值。
派生类对象的这些属性也适用于本身是对象的类成员。比如在一个类中声明一个string对象，string对象也采用动态内存分配，包含string对象的类会使用string的复制构造函数，赋值运算符和析构函数执行相关操作。
### 第二种情况：派生类使用new
假设派生类使用new，这种情况下必须为派生类定义显式的析构函数，复制构造函数和赋值运算符。
* 析构函数必须释放指针成员管理的内存，并依赖于基类的析构函数来释放基类指针成员管理的内存；
* 派生类的复制构造函数只能访问派生类的数据，因此它必须调用基类复制构造函数来处理共享的基类数据：
```C++
hasDMA::hasDMA(const hasDMA & hs):baseDMA(hs)
{
    style=new char[std::strlen(hs.style)+1];
    std::strcpy(style,hs.style);
}
```
成员初始化列表将一个hasDMA引用传递给baseDMA构造函数，因为复制构造函数baseDMA有一个baseDMA引用参数，而基类引用可以指向派生类，因此基类构造函数将使用派生类对象的基类部分来构造新对象的基类部分。
* 派生类的显式赋值运算符可以通过显式调用基类赋值运算符来完成基类对象的赋值：
```C++
hasDMA & hasDMA::operator=(const hasDMA & hs)
{
    if(this==&hs)
    return *this;
    baseDMA::operator=(hs);//copy base portion
    delete [] style;
    style=new char[std::strlen(hs.style)+1];
    std::strcpy(style,hs.style);
    return *this;
}
```
通过使用函数表示法，而不是运算符表示法就可以使用作用域解析符，防止调用到派生类的赋值运算符函数而不是基类导致递归调用。
### 派生类如何访问基类的友元
由于友元函数并非类成员，因此不能继承。
**派生类友元函数可以通过强制类型转换将派生类引用或指针转换为基类引用或指针，然后使用该引用或指针来调用基类的友元函数。**下面说明原因：
以重载<<运算符为例，我们已经知道重载<<运算符第一个参数是ostream对象，所以必须是友元函数。
派生类的友元函数能够访问派生类的数据成员，但派生类的友元函数不是基类的友元，它要如何访问基类的数据成员？
答案是使用基类的友元函数，也就是基类的重载<<运算符。不过还有一个问题，因为友元不是成员函数，所以不能使用作用域解析符来指出要使用哪个函数，所以必须要使用强制类型转换，以便匹配原型时能够选择正确的函数。
```C++
std::ostream & operator<<(std::ostream & os,const hasDMA & hs)
{
    //type cast to match operator<<(ostream &,const baseDMA &)
    os<<(const baseDMA &)hs;
    os<<"Style: "<<hs.style<<endl;
}
```
代码将参数const hasDMA &转换成类型为const baseDMA &的参数。
##十到十三章类设计总结提炼
见书427页，总结的非常详细。
另有一个成员函数属性表，在432页，值得一看。